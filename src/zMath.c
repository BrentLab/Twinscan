/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: t -*- */  
/******************************************************************************\
 zMath.c - part of the ZOE library for genomic analysis
 
 Copyright (C) 2001-2002 Ian F. Korf

\******************************************************************************/

#ifndef ZOE_MATH_C
#define ZOE_MATH_C

#include <assert.h>
#include "zMath.h"

const int zPOWER[6][11] = {
	{        1,        0,        0,        0,        0,        0,        0,        0,        0,        0,        0},
	{        1,        1,        1,        1,        1,        1,        1,        1,        1,        1,        1},
	{        1,        2,        4,        8,       16,       32,       64,      128,      256,      512,     1024},
	{        1,        3,        9,       27,       81,      243,      729,     2187,     6561,    19683,    59049},
	{        1,        4,       16,       64,      256,     1024,     4096,    16384,    65536,   262144,  1048576},
	{        1,        5,       25,      125,      625,     3125,    15625,    78125,   390625,  1953125,  9765625},
}; /* Generated by power.pl with $MAX_BASE=5, $MAX_EXPONENT=10 */

static const double zPI   = 3.1415926536;
static const double zLOG2 = 0.6931471806;

double  zLog2        (double x)   {return (log(x) / zLOG2);}
score_t zFloat2Score (double x)   {return (x == 0)?MIN_SCORE:(score_t)(zLog2(x) * 10);}
double  zScore2Float (score_t s)  {return (pow((double)2, ((double)s/10)));}

/* These are defined in zMathTable.c, generated by zFloatwiseScoreAdd.c */
extern float zFloatAddMax;
extern float zFloatAddScale;
extern float zFloatAddTable[];
extern int  zFloatAddCount;

static score_t zFloatwiseScoreAddHelper(score_t x) {
	int index;
	assert (!(x > 0));
	if (x <= zFloatAddMax) {
		return  0;
	} else {
		index = (int)(x*-zFloatAddScale); 
		assert (index < zFloatAddCount);
		return zFloatAddTable[index];
	}
}

score_t zFloatwiseScoreAdd(score_t p, score_t q) {
	score_t d;
	if (-10000 >= p) return q;
	if (-10000 >= q) return p;
	d = p - q;
	if (d < 0)  return q + zFloatwiseScoreAddHelper(d);
	else        return p + zFloatwiseScoreAddHelper(-d);
}

double zLnFactorial (int n) {
	double f;
	
	if (n == 0) return 0;
	
        /* Stirling's expansion.  See 
http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=046969
           for more denominators */
	f = (0.5 * log(2 * zPI))
		+ ((n + 0.5) * log((double)n))
		- n
		+ 1 / (12 * n)
		- 1 / (360 * pow((double)n, (double)3));
	return f;
}

/* some distributions (add normal, linear, etc. later) */

score_t zScoreGeometric (double m, double n, double x) {
	double f;
	double p = 1/ m;
	assert(x > 0);
	
	f = (x - 1) * log(1 - p) + log(p) + log(n);
	f /= zLOG2;
	f *= 10;
	return (score_t) f;
}

score_t zScorePoisson (double m, double x) {
	double f;
	
	f = (x * log(m)) - m - zLnFactorial((int)x);
	f /= log((double)2);
	f *= 10;
	return (score_t) f;
}

score_t zScorePolyScore(float *p, int n, double x)
{
   /* Score is computed using a polynomial of degree n */
   /* x is rescaled, i.e. rx = (x-lambda)/mu           */
   /* Lambda and mu are the last 2 elements in array p */

   double f, rx;
   int i, len, lambda;

   len = ((int) x);
   lambda = ((int) p[n+1]);

   if (len == lambda) /* rx = 0 */
     {
       return p[0];
     }
   else
     {
       f = p[n];
       rx = (x - p[n+1])/p[n+2];
       for (i = (n-1); i >= 0; i--)
          {
            f = (f*rx) + p[i];
          }
     }

   return (score_t) f;
}

/* base conversion - positive numbers only */

void zDecToBase (int n, int base, char *s) {
	int i = 0, j;
	char c;
	
	if (base > 9) zDie("zDecToBase limit 9 (%d)\n", base);
	if (n < 0) zDie("zDecToBase positive only (%d)\n", n);
	
	do {
		s[i++] = n % base + '0';
	} while ((n /= base) > 0);
	s[i] = '\0';
	
	for (i = 0, j = strlen(s) -1; i < j; i++, j--) {
		c = s[i];
		s[i] = s[j];
		s[j] = c;
	}
}

int zBaseToDec (int base, const char *s) {
	char c;
	int i, len, val = 0;
	
	if (base > 9) zDie("zBaseToDec limit 9 (%d)\n", base);
	
	len = strlen(s);
	for (i = 0; i < len; i++) {
		c = s[i] - '0';
		if (c < 0 || c > 9) zDie("zBaseToDec illegal symbol (%c)", s[i]);
		val += pow((float)base, (float)(len -i -1)) * c;
	}
	
	return val;
}


int zIntMax (int a, int b){
	if(a >= b){
		return a;
	}
	return b;
}

int zIntMin (int a, int b){
	if(a <= b){
		return a;
	}
	return b;
}

score_t zScoreMax (score_t a, score_t b){
	if(a >= b){
		return a;
	}
	return b;
}

score_t zScoreMin (score_t a, score_t b){
	if(a <= b){
		return a;
	}
	return b;
}


coor_t zCoorMax (coor_t a, coor_t b){
	if(a >= b){
		return a;
	}
	return b;
}

coor_t zCoorMin (coor_t a, coor_t b){
	if(a <= b){
		return a;
	}
	return b;
}


#endif
